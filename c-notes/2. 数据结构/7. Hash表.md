### 1. 一般哈希 

[AcWing 840. 模拟散列表](https://www.acwing.com/problem/content/842/)

+ 哈希表的时间复杂度都是 $O(1)$。

#### 1.1 拉链法

```cpp
int h[N], e[N], ne[N], idx;

// 向哈希表中插入一个数
void insert(int x)
{
    int k = (x % N + N) % N; // 正数mod是正数，负数mod是负数，为了让结果是正数，我们这么做
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx ++ ;
}

// 在哈希表中查询某个数是否存在
bool find(int x)
{
    int k = (x % N + N) % N;
    for (int i = h[k]; i != -1; i = ne[i])
        if (e[i] == x)
            return true;

    return false;
}
```

+ 用单链表实现拉链法

#### 1.2 开放寻址法

+ 经验：空间一般取题目给出范围的 2 ~ 3 倍。

```cpp
const int null = 0x3f3f3f3f;
int h[N];

memset(h, 0x3f, sizeof h);      // 给h的每个字节初始化成0x3f，使得每个元素的值都是null

// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
int find(int x)
{
    int t = (x % N + N) % N;
    while (h[t] != null && h[t] != x)
    {
        t ++ ;
        if (t == N) t = 0;
    }
    return t;
}
```

+ `(x % N + N) % N` 首先把 `x` 缩放到满足 `abs(x) < N`，由于第一次求余的结果可能是负数，因此还要再进行一次求余
+ 用质数作为长度可以使得冲突最少（数学能证明），可以事先实现一个求质数的函数，算出比 N 大的最小质数，作为 N 的值
+ 离散化是哈希的特例，因为离散化要求相对顺序不变，而哈希没有要求
+ 哈希表的删除是通过标记实现的
+ 开放寻址法手动设定 `null` 的值，其值可根据题目给出的元素数值范围设计。例如元素值的绝对值 $≤ 10^9$，又知 $0x3F3F3F3F >10^9$，但 memset 只能按字节赋值，故可考虑 0x3F3F3F3F，`memset(h, 0x3f, sizeof h);`为数组元素“赋”初值null。


### 2. 字符串哈希

[AcWing 841. 字符串哈希](https://www.acwing.com/problem/content/843/)

#### 2.1 模板

+ 核心思想：将字符串看成P进制数，**P的经验值是131或13331**，取这两个值的冲突概率低。
+ 小技巧：**取模的数用2^64**，这样直接用unsigned long long存储，溢出的结果就是取模的结果。

```cpp
typedef unsigned long long ULL;
const int P = 131;
ULL h[N], p[N]; // h[k]存储字符串前 k 个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i]; // 溢出的结果就是取模的结果
    p[i] = p[i - 1] * P; // 溢出的结果就是取模的结果，等效于 p[i - 1] * P mod 2^64
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1]; // z
}
```

#### 2.2 介绍

全称**字符串前缀哈希法**，把字符串变成一个 p 进制数字（哈希值），实现不同的字符串映射到不同的数字。

对形如 $X_1X_2X_3 \cdots X_{n−1}X_n$ 的字符串，采用字符的 `ascii` 码乘上 P 的次方来计算哈希值。

映射公式 $(X_1×P^{n−1}+X_2×P^{n−2}+ \cdots +X_{n−1}×P^1+X_n×P^0) \quad mod \quad Q$

注意点：

1. **任意字符不可以映射成 0，否则会出现不同的字符串都映射成 0 的情况，比如A，AA，AAA皆为 0。**
2. **冲突问题：通过巧妙设置 P (131 或 13331) , Q ($2^{64}$)的值，一般可以理解为不产生冲突。**

问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。

求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串哈希值就相当于求部分和。

前缀和公式： $h[i+1]=h[i]×P+s[i],\quad i∈[0,n−1]$ ，h为前缀和数组，s为字符串数组。

区间和公式： $h[l,r]=h[r]−h[l−1]×P^{r−l+1}$。区间和公式可以这么理解: $ABCDE$ 与 $ABC$ 的前三个字符值是一样，只差两位，乘上 P 的二次方把 $ABC$ 变为 $ABC00$，再用 $ABCDE - ABC00$ 得到 $DE$ 的哈希值。

#### 2.3 作用

1. 快速判断一个字符串的两个字串是否相等，就是模板题目。
2. 快速判断两个字符串是否相等。（参照Java的 `hashcode()`）
3. `kmp` 算法的劲敌。

#### 2.4 时间复杂度

$O(n)+O(m)$
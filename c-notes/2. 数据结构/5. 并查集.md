### 1. 并查集 

[AcWing 836. 合并集合](https://www.acwing.com/problem/content/838/)

[AcWing 837. 连通块中点的数量](https://www.acwing.com/problem/content/839/)

[AcWing 240. 食物链](https://www.acwing.com/problem/content/242/)

并查集：将两个集合合并；询问两个元素是否在一个集合当中

每个集合使用一个树来表示，**树根的编号就是整个集合的编号**，每个节点存储它的父节点，p[x] 表示 x 的父节点。

查找 x 父节点的时间复杂度比较大，可以优化，优化的方法有路径压缩和按秩合并，一般使用路径压缩，这个方法效果更好更简单。

路径压缩：找到祖先以后，将 $p[x]$ 存储成祖先。

使用路径压缩以后，时间复杂度近似 $O(1)$，但不是$O(1)$。

### 2. 朴素并查集

查找函数中使用了**路径压缩**优化并查集结构，使得每个非根结点直接连到根节点上，每棵树的深度不超过 2。

判断两个数是否属于同一个集合等价于判断两个数的祖宗结点是否相同，即 `find(a) == find(b)`。

合并操作本质是把其中一个祖宗结点连接到另一个祖宗结点上。

```cpp
int p[N]; //存储每个点的祖宗节点

// 返回x的祖宗节点，这是核心代码
int find(int x) {
    if (p[x] != x) {
        p[x] = find(p[x]); // 路径压缩
    }
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) p[i] = i;

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
```

### 3. 维护size的并查集

在合并操作中，可以不必把 `find(a)` 和 `find(b)` 存入两个变量。因为第一次调用 `find()` 时会进行路径压缩，下一次调用就是`O(1)` 复杂度了。

要注意先修改 `size` 再合并结点，二者顺序不可颠倒，因为结点含义会改变。

改变 `size` 时，要先判断两个集合是否为同一个。

在两个彼此不连通的连通图加上一条边连通二者，等价于把两个集合合并。

```cpp
int p[N]; // p[]存储每个点的祖宗节点
int size[N]; // size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

// 返回x的祖宗节点，这是核心代码
int find(int x) {
    if (p[x] != x) {
        p[x] = find(p[x]); // 路径压缩
    }
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) {
    p[i] = i;
    size[i] = 1;
}

// 合并a和b所在的两个集合：
size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```

### 4. 维护到祖宗节点距离的并查集

注意 `find` 函数语句的先后次序，次序不对可能会导致含义错误。

```cpp
int p[N]; // p[]存储每个点的祖宗节点
int d[N]; // d[x]存储x到p[x]的距离

// 返回x的祖宗节点
int find(int x) {
    if (p[x] != x) {
        int u = find(p[x]); // u是祖宗节点
        d[x] += d[p[x]]; // 当前节点有了新的祖宗节点，新的距离是原来的距离加上原来父节点到现在祖宗节点的距离
        p[x] = u; // 现在的父节点是u
    }
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) {
    p[i] = i;
    d[i] = 0;
}

p[find(a)] = find(b); // 合并a和b所在的两个集合：
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```


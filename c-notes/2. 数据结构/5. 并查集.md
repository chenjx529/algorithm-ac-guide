[toc]

### 1. 并查集 

[AcWing 836. 合并集合](https://www.acwing.com/problem/content/838/)

[AcWing 837. 连通块中点的数量](https://www.acwing.com/problem/content/839/)

[AcWing 240. 食物链](https://www.acwing.com/problem/content/242/)

#### 1.1 朴素并查集

```cpp
int p[N]; //存储每个点的祖宗节点

// 返回x的祖宗节点，这是核心代码
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) p[i] = i;

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
```

+ 查找函数中使用了**路径压缩**优化并查集结构，使得每个非根结点直接连到根节点上，每棵树的深度不超过 2。
+ 判断两个数是否属于同一个集合等价于判断两个数的祖宗结点是否相同，即 `find(a) == find(b)`。
+ 合并操作本质是把其中一个祖宗结点连接到另一个祖宗结点上。

#### 1.2 维护size的并查集

```cpp
int p[N], size[N];
//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

// 返回x的祖宗节点
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
    p[i] = i;
    size[i] = 1;
}

// 合并a和b所在的两个集合：
size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```

+ `size[x]` 存储的是以该结点为根的树的结点树。
+ 在合并操作中，可以不必把 `find(a)` 和 `find(b)` 存入两个变量。因为第一次调用 `find()` 时会进行路径压缩，下一次调用就是`O(1)` 复杂度了。但要注意先修改 `size` 再合并结点，二者顺序不可颠倒，因为结点含义会改变。
+ 改变 `size` 时，要先判断两个集合是否为同一个。
+ 在两个彼此不连通的连通图加上一条边连通二者，等价于把两个集合合并。
+ 为了避免合并步骤中出现顺序问题，可以用两个变量表示，同时也减少了代码量。

#### 1.3 维护到祖宗节点距离的并查集

```cpp
int p[N], d[N];
//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

// 返回x的祖宗节点
int find(int x)
{
    if (p[x] != x)
    {
        int u = find(p[x]); // u是父节点的父节点
        
        d[x] += d[p[x]];// 当前节点有了新的父节点，没有金国压缩，所以当前节点到父节点的距离是原来的距离加上原来父节点到现在父节点的距离
        p[x] = u; // 现在的父节点是u，和原来的p[x]t
    }
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
    p[i] = i;
    d[i] = 0;
}

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

+ 注意 `find` 函数语句的先后次序，次序不对可能会导致含义错误。



### 2. 什么是并查集

+ 将两个集合合并
+ 询问两个元素是否在一个集合当中



### 3. 基本原理

每个集合使用一个树来表示，**树根的编号就是整个集合的编号**，每个节点存储它的父节点，p[x] 表示 x 的父节点。

查找 x 父节点的时间复杂度比较大，可以优化，优化的方法有路径压缩和按秩合并，一般使用路径压缩，这个方法效果更好更简单。

**路径优化：找到祖先以后，将 $p[x]$ 存储成祖先。**



### 4. 解决问题

问题 1 ：如何判断树根：$if(p[x]==x)$

问题 2 ：如何求 x 的集合编号：$while(p[x] != x) x = p[x]$

问题 3 ：如何合并两个集合：$p_x$ 是 x 的集合编号，$p_y$  是 y 的集合编号。$p[x]=y$



### 5. 时间复杂度

使用路径压缩以后，时间复杂度近似 $O(1)$，但不是$O(1)$。
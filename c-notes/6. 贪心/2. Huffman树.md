## Huffman树

[AcWing 148. 合并果子](https://www.acwing.com/problem/content/150/)

[bailian4080](http://bailian.openjudge.cn/practice/4080/)

[POJ3253](http://poj.org/problem?id=3253)

[POJ1521](http://poj.org/problem?id=1521)

类型：贪心、哈夫曼树、堆、优先队列

### 1. 概述

 构造一棵哈夫曼树，是将所要编码的字符作为叶子节点，该字符在文件中的使用频率作为叶子节点的权值，**自底向上**的方式，通过 $n-1$次 "合并" 运算后构造出来的树。

核心思想是**让权值大的叶子离根最近**。哈夫曼算法采取的贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为子树，构造一棵新树，新树根节点的权值是左右孩子节点权值之和，将新树插入到树的集合中。

**带权路径长度WPL**：就是新生成的节点权值之和。

### 2. 合并果子思路

经典哈夫曼树的模型，每次合并重量最小的两堆果子即可。使用小根堆维护所有果子，每次弹出堆顶的两堆果子，并将其合并，合并之后将两堆重量之和再次插入小根堆中。每次操作会将果子的堆数减一，一共操作 $n−1$ ​ 次即可将所有果子合并成 1 堆。每次操作涉及到 2 次堆的删除操作和 1 次堆的插入操作，计算量是 $O(logn)$，因此总时间复杂度是 $O(nlogn)$。

### 3. 核心代码

```cpp
priority_queue<int, vector<int>, greater<int>> q;
res = 0  // 很有可能是 long long，这个需要注意

while (q.size() > 1)
{
    int a = q.top(); q.pop();
    int b = q.top(); q.pop();
    res += a + b;
    q.push(a + b);
}
```

